<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="/theme/css/style.css">
	<!--<link rel="stylesheet/less" type="text/css" href="/theme/css/style.less">-->
	<!--<script src="/theme/js/less.js" type="text/javascript"></script>-->
	<link rel="stylesheet" type="text/css" href="/theme/css/pygments.css">
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	<link href='//fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<link href="/" type="application/atom+xml" rel="alternate" title="The Lanterns ATOM Feed" />


		<title>The Lanterns</title>
		<meta charset="utf-8" />
</head>
<body>
	<section id="sidebar">
		<figure id="user_logo">
            <a href=""><div class="logo">&nbsp;</div></a>
		</figure>

		<div class="user_meta">
            <h1 id="user"><a href="" class="">Simon Popelier</a></h1>
			<h2></h2>
			<ul>
					<li><a href="https://github.com/SimonPop">GitHub</a></li>
					<li><a href="https://www.linkedin.com/in/simon-popelier/">LinkedIn</a></li>
			</ul>
		</div>
		<footer>
			<address>
				Powered by <a href="http://pelican.notmyidea.org/">Pelican</a>,
		                theme by <a href="https://github.com/wting/pelican-svbtle">wting</a>.
			</address>
		</footer>
	</section>

	<section id="posts">
	<header>
		<h1>Simon Popelier's blog</h1>
		<h3>Posted dim. 11 juin 2023</h3>
	</header>
	<article>
		<h1 id="title">
			<a href="/the-onion-topology.html" rel="bookmark"
				title="Permalink to The Onion Topology">The Onion Topology</a>
		</h1>
		<h1>Introduction</h1>
<p><em>This article will explain what Onion Networks are and what sets them appart in the domain of network robustness.</em></p>
<p>The onion structure is a kind of network topology adopted by some networks. </p>
<p>This structure can be decomposed by radial layers hence its name.</p>
<p>A layer is composed of the same degee nodes having an overrepresentation of edges in between themselves.</p>
<p>At the core can be found the highest degree nodes. From there, the degree decreases the more we move to radially distant layers. </p>
<p>In summary: same degree nodes are likely to be connected to same degree nodes, creating this layering effect degree by degree.</p>
<figure>
<div id="my_dataviz"></div>
<figcaption style="text-align: center;">Interactive onion network</figcaption>
</figure>

<p>They make for a special kind of structure due to their particular robustness to failures and perturbations.</p>
<h1>Robustness</h1>
<p>Robustness for networks is often measured in terms of how difficult it is to split the graph apart when successively removing nodes. This comes from the <a href="https://en.wikipedia.org/wiki/Percolation_theory">Percolation Theory</a> study and designates a network as robust if most of its nodes remain accessible to each other in case of successive failures.</p>
<p>In “most” of its nodes we have to understand, the nodes are part of the main <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">component</a>: the biggest group still connected.</p>
<h2>Scale-Free Networks</h2>
<p>Onion networks are scale-free. They should therefore be compared to other scale-free networks.</p>
<blockquote>
<p>“<em>Scale-free networks are networks whose degree distribution follows a power law</em>.”  - <a href="https://en.wikipedia.org/wiki/Scale-free_network">Wikipedia</a> - This means they have few high-degree nodes and exponentially more lower-degree nodes.</p>
</blockquote>
<p>For these categories of networks, a good property to have for being robust is <em>degree <a href="https://en.wikipedia.org/wiki/Assortativity">assortativity</a></em>: nodes like to be connected to same-degree nodes.</p>
<p>Although not all degree assortative graphs are onions, all onions are degree assortative. </p>
<h2>Intuition</h2>
<p>The reason behind the robustness of degree assortative graph can be intuitively seen by taking two opposite examples: </p>
<ol>
<li>An onion graph: degree assortative.</li>
<li>A decreasingly branching <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">tree</a>: not degree assortative.</li>
</ol>
<p>An attack, if selective, will likely target one of the higher-degree nodes.</p>
<p>Removing such a node in the tree instantly cuts the entire branch out of the main component. This is because of the hierarchical exclusivity that linked lower-level nodes to this single node to reach the root of the tree (and come back down to communicate to any other node).</p>
<table style="width:100%">
  <tr>
    <td><img src="imgs/onion-topology/tree.png" alt= "Tree example." width="100%">
    </td>
    <td><img src="imgs/onion-topology/broken_tree.png" alt= "Broken tree example." width="100%">
    </td>
  </tr>
  <caption style="caption-side:bottom">Same tree before and after ID removal of a node.</caption>
</table>

<p>Removing such a node in the onion does nothing like that. There is no hierarchical exclusivity: lower-level nodes that used to be linked to the removed node can still reach the core of the onion through pairs of the same layer still connected to the core, and accessible to them (thanks to assortativity).</p>
<table style="width:100%">
  <tr>
    <td><img src="imgs/onion-topology/onion.png" alt= "Tree example." width="100%">
    </td>
    <td><img src="imgs/onion-topology/broken_onion.png" alt= "Broken tree example." width="100%">
    </td>
  </tr>
  <caption style="caption-side:bottom">Same onion network before and after ID removal of a node.</caption>
</table>

<p>We can thus conclude that onions definitively have nothing to do with trees.</p>
<h2>Experiment</h2>
<p>This intuition can be backed by experimenting on attacks and comparing the performance of onion graphs and random other scale-free graphs.</p>
<p>The experience setup starts from intact networks and successively removes node after node. All along that process, we count the number of nodes still connected to the <em>main component</em>: the largest cluster of nodes still in reach one of the other.</p>
<p>The largest this component remains, the more robust the network structure is deemed. </p>
<p>This result is highly dependent on the order in which we chose to target nodes. </p>
<p>Generally, the node order strategy is chosen among four flavors:
- Initial Node Degrees (ID): Target the highest node degree computed on the initial network.
- Initial Node Betweenness (IB): Target the highest node betweenness computed on the initial network.
- Recomputed Node Degrees (RD): Target the highest node degree computed on the current state network (after all the previous removals).
- Recomputed Node Betweenness (RB): Target the highest node betweenness computed on the current state network (after all the previous removals).</p>
<p>As demonstrated by (Wu &amp; Holme, 2011) in their paper, the Onion graph (orange) is almost as robust as a robustnesss optimized graph (purple), and way better than a similar degree scale-free network (green) for an RD strategy.</p>
<p><img src="imgs/onion-topology/onion-vs-standard.PNG" alt= "Onion network robustness performance" width="100%"></p>
<h1>Generation</h1>
<p>How to acquire this Onion topology is the subject of this last section.</p>
<p>Initially, the topology has been discovered by optimizing for a robustness metric (Chan &amp; Akoglu, 2016; Louzada et al., 2013; Wu &amp; Holme, 2011). Starting from any graph, the algorithm swapped edges between nodes whenever that could bring an improvement in this metric. </p>
<blockquote>
<p>The robustness index formula follows: <div class="math">$$R = \frac{1}{N} \sum_{q=\frac{1}{N}} s(q)$$</div> with <span class="math">\(N\)</span>, the number of vertices, <span class="math">\(s(q)\)</span> is the fraction of vertices in the largest connected cluster after removing <span class="math">\(qN\)</span> vertices.</p>
</blockquote>
<p>The output of this process, for scale-free networks, systematically adopted the Onion topology.</p>
<p>Therefore, a way to get an Onion structure is to follow this optimization process.</p>
<p>However, (Wu &amp; Holme, 2011) asked themselves whether there could be a more direct method to generate such graphs, and came up with the following algorithm.</p>
<p><em>Algorithm: Onion structured network generation.</em>   </p>
<div class="highlight"><pre><span></span><code><span class="nv">DEFINE</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="nv">N</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">graph</span>.<span class="w">  </span>
<span class="k">FOR</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">node</span>,<span class="w"> </span><span class="nv">sample</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">degree</span><span class="w"> </span><span class="mh">$d</span><span class="nv">_i</span>$<span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">distribution</span><span class="w"> </span>$<span class="nv">P</span><span class="w"> </span><span class="ss">(</span><span class="nv">k</span><span class="ss">)</span><span class="w"> </span>∼<span class="w"> </span><span class="nv">k</span><span class="o">^</span>{−γ}$.<span class="w">  </span>
<span class="nv">ASSIGN</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">layer</span><span class="w"> </span>$<span class="nv">s_i</span>$<span class="w"> </span><span class="nv">given</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">sampled</span><span class="w"> </span><span class="nv">degree</span>.<span class="w">  </span>
<span class="k">FOR</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">node</span>,<span class="w"> </span><span class="nv">create</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">many</span><span class="w"> </span><span class="s2">&quot;stubs&quot;</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">degree</span><span class="w"> </span><span class="mh">$d</span><span class="nv">_i</span>$.<span class="w">   </span>
<span class="k">WHILE</span><span class="w"> </span><span class="nv">independant</span><span class="w"> </span><span class="s2">&quot;stubs&quot;</span><span class="w"> </span><span class="nv">remain</span>,<span class="w"> </span><span class="k">connect</span><span class="w"> </span><span class="nv">two</span><span class="w"> </span><span class="nv">stubs</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="k">random</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">probability</span><span class="w"> </span>$\<span class="nv">Pi_</span>{<span class="nv">ij</span>}<span class="w"> </span><span class="o">=</span><span class="w"> </span>\<span class="nv">frac</span>{<span class="mi">1</span>}{<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">a</span><span class="o">|</span><span class="nv">s_i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">s_j</span><span class="o">|</span>}$<span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="mh">$a</span>$<span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">control</span><span class="w"> </span><span class="nv">parameter</span>,<span class="w"> </span><span class="nv">starting</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">lowest</span><span class="w"> </span><span class="nv">degree</span><span class="w"> </span><span class="nv">nodes</span>.
</code></pre></div>

<h1>Conclusion</h1>
<p>Onion structure is a particularly robust topology for scale-free networks.</p>
<p>Such networks can be generated not only by optimizing an already existing structure but from the ground up using the presented algorithm.</p>
<p>It proves to resist well against traditional attacks and failures. These are usually focused on high-degree nodes. Although one could wonder what would happen in an attack designed specifically for this topology. What would happen with an attack focusing on the inter-layer nodes in priority?</p>
<h1>References</h1>
<p>Chan, H., &amp; Akoglu, L. (2016). Optimizing network robustness by edge rewiring : A general framework. Data Mining and Knowledge Discovery, 30(5), 1395‑1425. https://doi.org/10.1007/s10618-015-0447-5
Louzada, V. H. P., Daolio, F., Herrmann, H. J., &amp; Tomassini, M. (2013). Smart Rewiring for Network Robustness. Journal of Complex Networks, 1(2), 150‑159. https://doi.org/10.1093/comnet/cnt010
Wu, Z.-X., &amp; Holme, P. (2011, août 9). Onion structure and network robustness. ArXiv.Org. https://doi.org/10.1103/PhysRevE.84.026106</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>

		<div id="article_meta">
				Category:
					<a href="/category/graph-theory.html">Graph Theory</a>
				<br />Tags:
					<a href="/tag/graph-robustness.html">graph-robustness</a>
					<a href="/tag/theory.html">theory</a>
		</div>
	</article>

	<footer>
		<a href="/" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;Back to blog</a>
	</footer>


	</section>

					<script src="/js/onion_d3.js"></script>
</body>
</html>