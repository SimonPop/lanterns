<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="https://simonpop.github.io/theme/css/style.css">
	<!--<link rel="stylesheet/less" type="text/css" href="/theme/css/style.less">-->
	<!--<script src="/theme/js/less.js" type="text/javascript"></script>-->
	<link rel="stylesheet" type="text/css" href="https://simonpop.github.io/theme/css/pygments.css">
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	<link href='//fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<link href="https://simonpop.github.io/" type="application/atom+xml" rel="alternate" title="The Lanterns ATOM Feed" />


		<title>The Lanterns</title>
		<meta charset="utf-8" />
</head>
<body>
	<section id="sidebar">
		<figure id="user_logo">
            <a href="https://simonpop.github.io"><div class="logo">&nbsp;</div></a>
		</figure>

		<div class="user_meta">
            <h1 id="user"><a href="https://simonpop.github.io" class="">Simon Popelier</a></h1>
			<h2></h2>
			<p class="bio">Data Scientist and Graph Enthusiast.</p>
			<ul>
					<li><a href="https://github.com/SimonPop">GitHub</a></li>
					<li><a href="https://www.linkedin.com/in/simon-popelier/">LinkedIn</a></li>
			</ul>
		</div>
		<footer>
			<address>
				Powered by <a href="http://pelican.notmyidea.org/">Pelican</a>,
		                theme by <a href="https://github.com/wting/pelican-svbtle">wting</a>.
			</address>
		</footer>
	</section>

	<section id="posts">
	<header>
		<h1>Simon Popelier's blog</h1>
		<h3>Posted lun. 10 avril 2023</h3>
	</header>
	<article>
		<h1 id="title">
			<a href="https://simonpop.github.io/graph-structure-learning.html" rel="bookmark"
				title="Permalink to Graph Structure Learning">Graph Structure Learning</a>
		</h1>
		<h2>Introduction</h2>
<p><em>You are at the top of a tower overlooking the city and watch people come and go like a colony of ants. Some are running into subway stations, and some are running out of them. As the day progresses, you see patterns that govern the number of people coming and going at different stations, at different times. Your almost pathological love of Machine Learning tells you that it would certainly be possible to predict this pattern. You think of your friend Michael, a strong advocate of graphs, and you remark that the use of Graph Neural Networks would be perfectly relevant in this case! The metro network is obviously at the heart of this dynamic. However, you don't have the map in front of you. How to take advantage of this technology?</em></p>
<p><img src="./imgs/graph-structure-learning/banner.png" alt= "Banner" width="100%"></p>
<p>In this article, we will focus on Graph Structure Learning, a joint learning technique of the graph: the subway network, and the prediction object: the number of passengers at each station.</p>
<p>More generally, this technique allows the use of graph-based methods on data for which the existence of an underlying graph is suspected, but for which the available graph is noisy, partially or completely unknown.</p>
<p>The methods thus made available by the acquisition of a graph range from spectral techniques to the more recent use of Graph Neural Networks. The latter has been illustrated in recent years on different problems such as social network data (Fan et al., 2019), recommendations (Wu et al., 2022), or spatial analysis (Derrow-Pinion et al., 2021). </p>
<p>The purpose of this article is to illustrate the usefulness of such a method and to explain the different approaches succinctly. We will take as an example the prediction of traffic on a fictitious subway network.</p>
<h2>Motivation</h2>
<h3>Performance</h3>
<p>The main interest of such a method is above all to improve the performance of a model. This is done by adding an inductive bias that characterizes the problem as a graph problem. The performance is then improved by learning or refining this graph, helping the model to structure the inputs in a way that is adapted to the solution of the problem.</p>
<h3>Explainability</h3>
<p>Another reason to use such a module would be to be able to better understand the environment in which we work. Indeed, graphs allow a clear visualization and are anchored in the reality of the problem on which we can project ourselves to make the analysis. </p>
<p>In our example, it could allow us to reveal the subway network until now hidden to the observer. This is also the idea behind Graph WaveNet (Wu et al., 2019).</p>
<p>However, it should be noted that as the neural network grows in size, the underlying graph used by it may be distinct from the graph a human would tend to read things from. </p>
<p>E.g. Even though the performance of the network is improved in the presence of the graph, the MTGNN model (Wu et al., 2020) hardly produces a human-readable graph.  </p>
<p>In this case, we can talk about explainability and not only interpretability, since we are talking about the analysis of the neural network itself and the way it has modeled the problem.</p>
<h3>Adversarial</h3>
<p>Finally, it is also possible to use this mechanism as a protection against graph traffickers. Indeed, as for any type of data, it is possible to knowingly alter the prediction of a network to take advantage of it. This can be the case for example for a recommendation engine for which one would like to bias the prediction in favor or against a particular product. Graph Structure Learning can then rectify this graph, correcting in particular the inappropriate edges. This is what (Jin et al., 2020) call Graph Purification.</p>
<h2>Implementations</h2>
<h3>Paradigms</h3>
<p>There are different ways to use an SLM module within a neural network architecture. </p>
<p><img src="./imgs/graph-structure-learning/paradigms_blocs.png" alt= "Bloc description" width="100%"></p>
<p>1) Joint paradigm</p>
<p>A simple solution in which a single GSL block is used, followed by the rest of the GNN.</p>
<p>2) Adaptive paradigm</p>
<p>A solution in which a succession of GSL-GNN blocks is used. This is for example the case with the MTGNN architecture (Wu et al., 2020).</p>
<p>3) Iterative paradigm</p>
<p>A solution that resembles the previous one, but that does not stipulate a fixed number of blocks but rather a condition from which we stop applying this block in a loop (Chen et al., 2020).</p>
<p><img src="./imgs/graph-structure-learning/paradigms.png" alt= "Paradigms" width="100%"></p>
<h3>Constraints on the graph</h3>
<p>When learning a graph, we will often want to constrain it to respect the attributes that graphs in general include.</p>
<p>There are two ways to enforce these constraints: regularization (by altering the loss function) and architectural constraint (by altering the neural network itself).</p>
<p>We will focus on the most frequently used attributes, but there are others.</p>
<h4>Constraints by regularization</h4>
<p>With regularization techniques, we alter the loss function to orient the learning of the graph: </p>
<div class="math">$$
L = L_{pred} + \lambda L_{reg}
$$</div>
<p>In particular, we can enforce various constraints mentioned by (Kalofolias, 2016).</p>
<ul>
<li><strong>Smoothness</strong>: In a homophily context (connected nodes are similar), we want to make sure that connected nodes have a close representation.</li>
</ul>
<div class="math">$$
L_{reg}(A, X) = \frac{1}{2}\sum A_{ij}(x_i-x_j)^2
$$</div>
<p>Conversely, we could place ourselves in a heterophily context where we want the connected nodes to have distant embeddings.</p>
<p align="center">
    <img src="./imgs/graph-structure-learning/smoothness.png" alt= "Smoothness" width="50%">
</p>

<ul>
<li><strong>Sparsity</strong>: In reality, graphs are sparse, i.e. each node has only a few neighbors relative to the total number of nodes in the graph. To proceed, we can penalize the <span class="math">\(l_0\)</span> norm of the learned <span class="math">\(A\)</span>-adjacency matrix:</li>
</ul>
<div class="math">$$
L_{reg}(A) = ||A||_0
$$</div>
<p align="center">
    <img src="./imgs/graph-structure-learning/sparsity.png" alt= "Sparsity" width="50%">
</p>

<ul>
<li><strong>Connectivity</strong>: We will also want to obtain a connected graph most of the time. For this we can rely on the rank of the adjacency matrix: the lower the rank, the more densely connected the graph is:</li>
</ul>
<div class="math">$$
L_{reg}(A) = rank(A)
$$</div>
<ul>
<li><strong>Degree positivity</strong>: A trivial solution to these equations being a null matrix, we can emphasize the importance of having a positive degree for each node by using the following formula:</li>
</ul>
<div class="math">$$
L_{reg}(A) = -1^Tlog(A1)
$$</div>
<h4>Architectural constraints</h4>
<ul>
<li><strong>Directivity</strong>: We can impose or not that the graph is directed. That is to say, allow <span class="math">\(A_{ij} \neq A_{ji}\)</span>. For this, the matrix must be non-symmetric. So, in the context of node embeddings, we want to have a distance <span class="math">\(d(X_i, X_j)\)</span> which is not symmetric for a directed graph, and symmetric for an undirected graph. The MTGNN architecture (Wu et al., 2020) proposes for example learning two embeddings per node to differentiate one direction or the other of an edge.</li>
</ul>
<p align="center">
    <img src="./imgs/graph-structure-learning/directed.png" alt= "Directivity" width="50%">
</p>

<ul>
<li>
<p><strong>Positivity</strong>: We may wish to guarantee the positivity of the edges of the graph, for that it is possible to nullify the negative values: <span class="math">\(A' = ReLU(A)\)</span>, or to make them positive <span class="math">\(A' = exp(A)\)</span>.</p>
</li>
<li>
<p><strong>Sparsity</strong>: This is another method to ensure sparsity. Here, we can also use the function <span class="math">\(ReLU\)</span> to nullify the values below a certain threshold and thus ensure a <span class="math">\(\epsilon-graph\)</span>. Another way to do this is to use a <span class="math">\(kNN\)</span> graph and choose the highest values in the adjacency matrix.</p>
</li>
<li>
<p><strong>Discretization</strong>: We can wish that the edges of the graph are binary or not. If this is the case, we can use sampling or RL methods to ensure this. It is simpler and often preferable however to stick to weighted graphs, which offer more flexibility and easier learning methods because they are more easily differentiable.</p>
</li>
</ul>
<h3>Architecture</h3>
<p>There are three notable architectures for learning a graph. All these architectures lead to the computation of an adjacency matrix, but do it differently.</p>
<ul>
<li>Direct optimization</li>
</ul>
<p>In this architecture, we will directly optimize the adjacency matrix <span class="math">\(A\)</span>, as a free parameter. This is for example the case with the GLNN architecture (Gao et al., 2019).</p>
<p><img src="./imgs/graph-structure-learning/adjacency_matrix.png" alt= "Adjacency Matrix" width="100%"></p>
<ul>
<li>Metric-based approaches</li>
</ul>
<p>This approach uses a distance metric to estimate the edge weight between two nodes from the two embeddings of these nodes.  This allows the addition of new nodes if the embeddings of the nodes contain sufficient information to do so.</p>
<p>For example, a classical metric like cosine similarity(Nguyen &amp; Bai, 2011) can be used: </p>
<div class="math">$$
A = cos(w\odot v_i, w\odot v_j)
$$</div>
<p>with <span class="math">\(w\)</span> a trainable parameter. This is the case for example for the IDGL architecture (Chen et al., 2020).</p>
<p><img src="./imgs/graph-structure-learning/similarity.png" alt= "Similarity" width="100%"></p>
<p>Some more complex methods can also replace classical metrics. One thinks for instance of <strong>attention mechanisms</strong> (Veličković et al., 2018).</p>
<p>A last approach, <strong>structure-aware learning</strong>, additionally considers the attributes of the edge between the two nodes to establish the weight of the latter.</p>
<h2>Conclusion</h2>
<p>Graph Structure Learning methods are an excellent way to enable the use of graph methods that recent successes make attractive, by correcting or learning the structure to work on.</p>
<p>In this article, we have given a first overview of these techniques: the reasons why they are used, how they are incorporated into a DNN network, their architecture, and the constraints they impose on the learned graph.</p>
<p>This is a very active area of research and the points discussed here are far from exhaustive.</p>
<p>This paper is based on the overviews of (Zhu et al., 2022) and (Chen, Yu, and Wu, Lingfei, 2022).</p>
<p>We will experiment with a simple SLM method in a future paper.</p>
<h2>Bibliography</h2>
<p>Chen, Y., Wu, L., &amp; Zaki, M. J. (2020). <em>Iterative Deep Graph Learning for Graph Neural Networks : Better and Robust Node Embeddings</em> (arXiv:2006.13009). arXiv. <a href="https://doi.org/10.48550/arXiv.2006.13009">https://doi.org/10.48550/arXiv.2006.13009</a></p>
<p>Derrow-Pinion, A., She, J., Wong, D., Lange, O., Hester, T., Perez, L., Nunkesser, M., Lee, S., Guo, X., Wiltshire, B., Battaglia, P. W., Gupta, V., Li, A., Xu, Z., Sanchez-Gonzalez, A., Li, Y., &amp; Veličković, P. (2021). ETA Prediction with Graph Neural Networks in Google Maps. <em>Proceedings of the 30th ACM International Conference on Information &amp; Knowledge Management</em>, 3767‑3776. <a href="https://doi.org/10.1145/3459637.3481916">https://doi.org/10.1145/3459637.3481916</a></p>
<p>Fan, W., Ma, Y., Li, Q., He, Y., Zhao, E., Tang, J., &amp; Yin, D. (2019). Graph Neural Networks for Social Recommendation. <em>The World Wide Web Conference</em>, 417‑426. <a href="https://doi.org/10.1145/3308558.3313488">https://doi.org/10.1145/3308558.3313488</a></p>
<p>Gao, X., Hu, W., &amp; Guo, Z. (2019). <em>Exploring Structure-Adaptive Graph Learning for Robust Semi-Supervised Classification</em> (arXiv:1904.10146). arXiv. <a href="https://doi.org/10.48550/arXiv.1904.10146">https://doi.org/10.48550/arXiv.1904.10146</a></p>
<p><em>GNNBook@2023 : Graph Neural Networks : Graph Structure Learning</em>. (s. d.). Consulté 10 avril 2023, à l’adresse <a href="https://graph-neural-networks.github.io/gnnbook_Chapter14.html">https://graph-neural-networks.github.io/gnnbook_Chapter14.html</a></p>
<p>Jin, W., Li, Y., Xu, H., Wang, Y., Ji, S., Aggarwal, C., &amp; Tang, J. (2020). <em>Adversarial Attacks and Defenses on Graphs : A Review, A Tool and Empirical Studies</em> (arXiv:2003.00653). arXiv. <a href="https://doi.org/10.48550/arXiv.2003.00653">https://doi.org/10.48550/arXiv.2003.00653</a></p>
<p>Kalofolias, V. (2016). <em>How to learn a graph from smooth signals</em> (arXiv:1601.02513). arXiv. <a href="https://doi.org/10.48550/arXiv.1601.02513">https://doi.org/10.48550/arXiv.1601.02513</a></p>
<p>Nguyen, H. V., &amp; Bai, L. (2011). Cosine Similarity Metric Learning for Face Verification. In R. Kimmel, R. Klette, &amp; A. Sugimoto (Éds.), <em>Computer Vision – ACCV 2010</em> (p. 709‑720). Springer. <a href="https://doi.org/10.1007/978-3-642-19309-5_55">https://doi.org/10.1007/978-3-642-19309-5_55</a></p>
<p>Veličković, P., Cucurull, G., Casanova, A., Romero, A., Liò, P., &amp; Bengio, Y. (2018). <em>Graph Attention Networks</em> (arXiv:1710.10903). arXiv. <a href="https://doi.org/10.48550/arXiv.1710.10903">https://doi.org/10.48550/arXiv.1710.10903</a></p>
<p>Wu, S., Sun, F., Zhang, W., Xie, X., &amp; Cui, B. (2022). <em>Graph Neural Networks in Recommender Systems : A Survey</em> (arXiv:2011.02260). arXiv. <a href="https://doi.org/10.48550/arXiv.2011.02260">https://doi.org/10.48550/arXiv.2011.02260</a></p>
<p>Wu, Z., Pan, S., Long, G., Jiang, J., Chang, X., &amp; Zhang, C. (2020). <em>Connecting the Dots : Multivariate Time Series Forecasting with Graph Neural Networks</em> (arXiv:2005.11650). arXiv. <a href="https://doi.org/10.48550/arXiv.2005.11650">https://doi.org/10.48550/arXiv.2005.11650</a></p>
<p>Zhu, Y., Xu, W., Zhang, J., Du, Y., Zhang, J., Liu, Q., Yang, C., &amp; Wu, S. (2022). <em>A Survey on Graph Structure Learning : Progress and Opportunities</em> (arXiv:2103.03036). arXiv. <a href="https://doi.org/10.48550/arXiv.2103.03036">https://doi.org/10.48550/arXiv.2103.03036</a></p>
<p>Wu, Z., Pan, S., Long, G., Jiang, J., &amp; Zhang, C. (2019). <em>Graph WaveNet for Deep Spatial-Temporal Graph Modeling</em> (arXiv:1906.00121). arXiv. <a href="https://doi.org/10.48550/arXiv.1906.00121">https://doi.org/10.48550/arXiv.1906.00121</a></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>

		<div id="article_meta">
				Category:
					<a href="https://simonpop.github.io/category/graphml.html">GraphML</a>
				<br />Tags:
					<a href="https://simonpop.github.io/tag/graph-structure-learning.html">graph-structure-learning</a>
					<a href="https://simonpop.github.io/tag/theory.html">theory</a>
					<a href="https://simonpop.github.io/tag/overview.html">overview</a>
		</div>
	</article>

	<footer>
		<a href="https://simonpop.github.io/" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;Back to blog</a>
	</footer>


	</section>

</body>
</html>